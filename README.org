#+STARTUP: showall indent
#+OPTIONS: tex:t toc:nil H:6 ^:{}
#+ODT_STYLES_FILE: "/Users/gilgamesh/Google Drive/Templates/styles.xml"

#+TITLE: Programming in Python
#+AUTHOR: Derek Devnich

* Week 1: Fundamentals
** Orientation
*** What programming language should I use?
1. Use the language that your friends use (so you can ask them for help)
2. Use a language that has a community of practice for your desired use case (you can find documentation, bug reports, sample code, etc.)
3. Use a language that is "best" by some technical definition
*** Python is pretty good at lots of things
*** Literate programming and notebooks
- Blend code, documentation, and visualization
- Good for trying things, demos
- Bad for massive or long-running processes

** Jupyter commands
*** How to start Jupyter Lab
**** Method 1
1. Open Anaconda Navigator
2. Run Jupyter Lab
**** Method 2
Open Terminal (MacOS/Linux) or Anaconda Prompt (Windows)
#+BEGIN_SRC bash
cd Desktop/data
jupyter lab
#+END_SRC

*** Execute cell with CTRL-Enter; execute cell and move to new cell with Shift-Enter
#+BEGIN_SRC python
3 + 7
#+END_SRC

*** Navigation
- Use drag-and-drop interface to move .ipynb file to new location
- Rename your notebook to something informative

** Data Types and Type Conversion
*** Every value has a type
Most data is text and numbers:
- Integers: whole numbers (counting)
- Floats: real numbers (math)
- Strings: text
- ...and many others

*** Numbers
**** Common math operations can combine integers and floats
#+BEGIN_SRC python
1 / 2.0
#+END_SRC

**** We can display more interesting output with the ~print()~ function
#+BEGIN_SRC python
print('half is', 1 / 2.0)
print('three squared is', 3.0 ** 2)
#+END_SRC

**** Counting operations require integers
#+BEGIN_SRC python
print(10 % 3)                   # "Modulus", or remainder
#+END_SRC

*** Use the built-in function ~type()~ to find the type of a value
#+BEGIN_SRC python
type(53)
#+END_SRC

#+BEGIN_SRC python
type(3.12)
#+END_SRC

#+BEGIN_SRC python
type('Derek')
#+END_SRC

*** Must convert strings to numbers or vice versa when operating on them
#+BEGIN_SRC python
1 + '2'                         # Produces an error
#+END_SRC

#+BEGIN_SRC python
1 + float('2')
#+END_SRC

#+BEGIN_SRC python
# You can embed functions inside other functions
print(str(43))
print(int('3'))
print(float('3'))
#+END_SRC

** Variables and Assignment
*** Use variables to store values
Variables are names for values.
#+BEGIN_SRC python
first_name = 'Derek'
age = 42
#+END_SRC
- can only contain letters, digits, and underscore _ (typically used to separate words in long variable names)
- cannot start with a digit
- are case sensitive (~age~, ~Age~ and ~AGE~ are three different variables)

*** Use ~print()~ to display values
#+BEGIN_SRC python
print(first_name, 'is', age, 'years old')
#+END_SRC
- Functions are verbs; recognizable by ()
- Functions take arguments (i.e. do stuff with the values that you give them)
- ~print()~ useful for tracking progress, debugging
- NB: Jupyter Lab will always echo the *last* value in a cell, so we won't need ~print()~ a lot of the time

*** Variables must be created before they are used
#+BEGIN_SRC python
# Prints an informative error message; more about this later
print(last_name)
#+END_SRC

*** Variables can be used in calculations
#+BEGIN_SRC python
age = age + 3
print('Age in three years:', age)
#+END_SRC

*** Variables only change value when something is assigned to them
#+BEGIN_SRC python
first = 1
second = 5 * first
first = 2
print('first is', first, 'and second is', second)
#+END_SRC

*** Use meaningful names!

** Built-in Functions and Help
*** Online resources
- https://libguides.ucmerced.edu/software-carpentry/python/references
- Stack Overflow

*** Use comments to add documentation to programs
#+BEGIN_SRC python
# This sentence isn't executed by Python.
adjustment = 0.5   # Neither is this - anything after '#' is ignored.
#+END_SRC

*** A function may take zero or more arguments
#+BEGIN_SRC python
print('before')
print()
print('after')
#+END_SRC

*** Commonly-used built-in functions include ~max()~, ~min()~, and ~round()~
#+BEGIN_SRC python
max(1, 2, 3)
#+END_SRC

#+BEGIN_SRC python
min('a', 'A', '0')       # 0-9, A-Z, a-z; However, notice they are all strings!
#+END_SRC

*** Functions may only work for certain (combinations of) arguments
#+BEGIN_SRC python
max(1, 'a')              # Not a meaningful comparision
#+END_SRC

*** Functions may have default values for some arguments
#+BEGIN_SRC python
# By defualt, we round to the nearest integer
round(3.712)
#+END_SRC

#+BEGIN_SRC python
# You can optionally specify the number of significant digits
round(3.712, 1)
#+END_SRC

*** Use the built-in function ~help()~ to get help for a function
#+BEGIN_SRC python
help(round)
#+END_SRC
- 1 mandatory argument
- 1 optional argument with a default value: ~ndigits=None~

*** Python reports a syntax error when it can’t understand the source of a program
#+BEGIN_SRC python
name = 'Bob
age = = 54
print("Hello world"
#+END_SRC

*** Python reports a runtime error when something goes wrong while a program is executing
We have seen some of these already.

** Libraries
*** Most of the power of a programming language is in its libraries
https://docs.python.org/3/library/index.html
*** A program must ~import~ a library module before using it
#+BEGIN_SRC python
import math

print('pi is', math.pi)
print('cos(pi) is', math.cos(math.pi))
#+END_SRC
- Refer to things from the module as ~module-name.thing-name~
- Python uses "." to mean "part of" or "belongs to".

*** Use ~help()~ to learn about the contents of a library module
#+BEGIN_SRC python
help(math)                      # user friendly
#+END_SRC

#+BEGIN_SRC python
dir(math)                       # brief reminder, not user friendly
#+END_SRC

*** Import specific items from a library module to shorten programs.
You want to be careful with this. It's safer to keep the namespace.
#+BEGIN_SRC python
from math import cos, pi

print('cos(pi) is', cos(pi))
#+END_SRC

*** Create an alias for a library module when importing it to shorten programs
#+BEGIN_SRC python
import math as m

print('cos(pi) is', m.cos(m.pi))
#+END_SRC

** Lists
*** A list stores many values in a single structure
#+BEGIN_SRC python
pressures = [0.273, 0.275, 0.277, 0.275, 0.276]
print('pressures:', pressures)
print('length:', len(pressures))
#+END_SRC

*** Use an item’s index to fetch it from a list
#+BEGIN_SRC python
print('zeroth item of pressures:', pressures[0])
print('fourth item of pressures:', pressures[4])
#+END_SRC

*** Count backwards from the end with negative integers
#+BEGIN_SRC python
print('last item of pressures:', pressures[-1])
#+END_SRC

*** Use a slice to get a subset of the list
The slicing syntax is ~my_list[inclusive_start_position:exclusive_stop_position:optional_step_amount]~
#+BEGIN_SRC python
# Up to, but not including 3
print('first 3 items of pressures:', pressures[0:3])
#+END_SRC

*** Indexing beyond the end of the collection is an error
#+BEGIN_SRC python
pressures[20]
#+END_SRC

*** Lists’ values can be replaced by assigning to them
#+BEGIN_SRC python
pressures[0] = 0.265
print('pressures is now:', pressures)
#+END_SRC

*** Appending items to a list lengthens it
#+BEGIN_SRC python
primes = [2, 3, 5]
print('primes is initially:', primes)
primes.append(7)
print('primes has become:', primes)
#+END_SRC
- ~append()~ is a /method/ of lists. Methods are like functions, but they are tied to particular objects.
- Use ~object-name.method-name()~ to call methods
- Deliberately resembles the way we refer to things in a library
- We will meet other methods of lists as we go along; use ~help(list)~ for a preview.

*** Extend is similar to append, but allows you to merge two lists
#+BEGIN_SRC python
teen_primes = [11, 13, 17, 19]
middle_aged_primes = [37, 41, 43, 47]
print('primes is currently:', primes)
primes.extend(teen_primes)
print('primes has now become:', primes)
primes.append(middle_aged_primes)
print('primes has finally become:', primes)
#+END_SRC

*** Use del to remove items from a list entirely
#+BEGIN_SRC python
primes = [2, 3, 5, 7, 9]
print('primes before removing last item:', primes)
del primes[4]
print('primes after removing last item:', primes)
#+END_SRC

*** The empty list contains no values
Helpful for collecting values

*** Lists may contain values of different types
#+BEGIN_SRC python
location = ['latitude', 37.28306, 'N', 'longitude', 120.50778, 'W']
#+END_SRC

*** Strings can be indexed like lists
**** Use an index to get a single character from a string
Count from 0
#+BEGIN_SRC python
element = 'carbon'
element[0]
#+END_SRC

**** Use a slice to get a substring
#+BEGIN_SRC python
# Up to, but not including 3
sample = element[0:3]
print(sample)
#+END_SRC

**** Counting backwards
#+BEGIN_SRC python
element[-1]
#+END_SRC

**** Use the built-in function ~len()~ to find the length of a string
#+BEGIN_SRC python
len('carbon')                   # length is an integer
#+END_SRC

*** But! Character strings are immutable
#+BEGIN_SRC python
element[0] = 'C'
#+END_SRC

*** Python is full of analogies
- lists and strings
- lists and files

** For Loops
*** A ~for~ loop executes commands once for each value in a collection
"For each thing in this group, do these operations"
#+BEGIN_SRC python
for number in [2, 3, 5]:
    print(number)
#+END_SRC
- A for loop is made up of a collection, a loop variable, and a body
- The collection, *[2, 3, 5]*, is what the loop is being run on.
- The body, *print(number)*, specifies what to do for each value in the collection.
- The loop variable, *number*, is what changes for each iteration of the loop (i.e. the “current thing”)

*** The first line of the ~for~ loop must end with a colon, and the body must be indented
#+BEGIN_SRC python
# This produces an error
for number in [2, 3, 5]:
print(number)
#+END_SRC

#+BEGIN_SRC python
# So does this
firstName = "Jon"
  lastName = "Smith"
#+END_SRC

*** Loop variables can be called anything
#+BEGIN_SRC python
for kitten in [2, 3, 5]:
    print(kitten)
#+END_SRC
- It's just a placeholder

*** The body of a loop can contain many statements
#+BEGIN_SRC python
primes = [2, 3, 5]
for p in primes:
    squared = p ** 2
    cubed = p ** 3
    print(p, squared, cubed)
#+END_SRC

*** Use ~range()~ to iterate over a sequence of numbers
#+BEGIN_SRC python
for number in range(0, 3):
    print(number)
#+END_SRC
- range() produces numbers on demand (a "generator" function)
- useful for tracking progress

*** The Accumulator pattern turns many values into one
#+BEGIN_SRC python
# Sum the first 10 integers.
total = 0
for number in range(1, 11):
   total = total + number
print(total)
#+END_SRC

** Other containers
- Dictionaries
- Tuples
- Sets

** Homework
*** Read the following help files:
#+BEGIN_SRC python
help('')
help([])
#+END_SRC
*** Try to find 2 ways to capitalize 'carbon'

* Week 2: Building Programs
#+BEGIN_SRC python
#+END_SRC
** Conditionals
*** Use ~if~ statements to control whether or not a block of code is executed
An ~if~ statement (more properly called a conditional statement) controls whether some block of code is executed or not.
Structure is similar to a ~for~ statement:
  - First line opens with ~if~ and ends with a colon
  - Body containing one or more statements is indented (usually by 4 spaces)
#+BEGIN_SRC python
mass = 3.54
if mass > 3.0:
    print(mass, 'is large')

mass = 2.07
if mass > 3.0:
    print (mass, 'is large')
#+END_SRC

*** Conditionals are often used inside loops
Not much point using a conditional when we know the value (as above), but useful when we have a collection to process.
#+BEGIN_SRC python
masses = [3.54, 2.07, 9.22, 1.86, 1.71]
for m in masses:
    if m > 3.0:
        print(m, 'is large')
#+END_SRC

*** Use else to execute a block of code when an if condition is not true
~else~ can be used following an ~if~. This allows us to specify an alternative to execute when the if branch isn’t taken.
#+BEGIN_SRC python
masses = [3.54, 2.07, 9.22, 1.86, 1.71]
for m in masses:
    if m > 3.0:
        print(m, 'is large')
    else:
        print(m, 'is small')
#+END_SRC

*** Use ~elif~ to specify additional tests
May want to provide several alternative choices, each with its own test; use ~elif~ (short for “else if”) and a condition to specify these.
#+BEGIN_SRC python
masses = [3.54, 2.07, 9.22, 1.86, 1.71]
for m in masses:
    if m > 9.0:
        print(m, 'is HUGE')
    elif m > 3.0:
        print(m, 'is large')
    else:
        print(m, 'is small')
#+END_SRC
- Always associated with an ~if~.
- Must come before the ~else~ (which is the “catch all”).

*** Conditions are tested once, in order
Python steps through the branches of the conditional in order, testing each in turn.
Order matters!
#+BEGIN_SRC python
grade = 85
if grade >= 70:
    print('grade is C')
elif grade >= 80:
    print('grade is B')
elif grade >= 90:
    print('grade is A')
#+END_SRC

***  Use conditionals in a loop to “evolve” the values of variables
#+BEGIN_SRC python
velocity = 10.0
for i in range(5): # execute the loop 5 times
    print(i, ':', velocity)
    if velocity > 20.0:
        print('moving too fast')
        velocity = velocity - 5.0
    else:
        print('moving too slow')
        velocity = velocity + 10.0
print('final velocity:', velocity)
#+END_SRC

*** Compound Relations Using ~and~, ~or~, and Parentheses
Often, you want some combination of things to be true. You can combine relations within a conditional using ~and~ and ~or~. Continuing the example above, suppose you have:
#+BEGIN_SRC python
mass     = [ 3.54,  2.07,  9.22,  1.86,  1.71]
velocity = [10.00, 20.00, 30.00, 25.00, 20.00]

i = 0
for i in range(5):
    if mass[i] > 5 and velocity[i] > 20:
        print("Fast heavy object.  Duck!")
    elif mass[i] > 2 and mass[i] <= 5 and velocity[i] <= 20:
        print("Normal traffic")
    elif mass[i] <= 2 and velocity[i] <= 20:
        print("Slow light object.  Ignore it")
    else:
        print("Whoa!  Something is up with the data.  Check it")
#+END_SRC
- Use () to group subsets of conditions
- Aside: For a more natural way of working with many lists, look at ~zip()~

** Files
*** Open the file with a context handler
#+BEGIN_SRC python
with open('pettigrew_letters_ORIGINAL.txt', 'r') as file_in:
    text = file_in.read()

print(len(text))
#+END_SRC

*** Strings contain formatting marks
Compare the following:
#+BEGIN_SRC python
# This displays the nicely-formatted document
print(text[:50])
#+END_SRC

#+BEGIN_SRC python
# This shows the true nature of the string; you can see newlines (/n),
# tabs (/t), and other hidden characters
text[:50]
#+END_SRC

*** Many ways of handling a file
**** ~.read()~ produces the file contents as one string
#+BEGIN_SRC python
type(text)
#+END_SRC

**** ~.readlines()~ produces the file contents as a list of lines; each line is a string
#+BEGIN_SRC python
with open('pettigrew_letters_ORIGINAL.txt', 'r') as file_in:
    text = file_in.readlines()

print(len(text))
print(type(text))
#+END_SRC

**** Inspect parts of the file using list syntax
#+BEGIN_SRC python
# View the first 10 lines
text[:10]
#+END_SRC

*** Working with unstructured file data
**** Contents of pettigrew_letters_ORIGINAL.txt
1. Intro material
2. Manifest of letters
3. Individual letters

**** Query: Are all the letters in the manifest actually there?
1. check if all the letters reported in the manifest appear in the actual file
2. check if all the letters in the file are reported in the manifest
3. Therefore, construct two variables: (1) A list of every location line from the manifest, and (2) a list of every location line within the file proper

**** Get the manifest by visual inspection
#+BEGIN_SRC python
manifest_list = text[15:160]
#+END_SRC

**** Use string functions to clean up and inspect text
#+BEGIN_SRC python
# Raw text
for location in manifest_list[:10]:
    print(location)
#+END_SRC

#+BEGIN_SRC python
# Remove extra whitespace
for location in manifest_list[:10]:
    print(location.strip())
#+END_SRC

#+BEGIN_SRC python
# Test whether the cleaned line starts with 'Box '
for location in manifest_list[:10]:
    stripped_line = location.strip()
    print(stripped_line.startswith('Box '))
#+END_SRC

#+BEGIN_SRC python
# Test whether the cleaned line starts with 'box '
for location in manifest_list[:10]:
    stripped_line = location.strip()
    print(stripped_line.startswith('box '))
#+END_SRC

**** Gather all the locations in the full document
#+BEGIN_SRC python
letters = text[159:]

for line in letters[:25]:
    # Create a variables to hold current line and truth value of is_box
    stripped_line = line.strip()
    is_box = stripped_line.startswith('Box ')
    if is_box == True:
        print(stripped_line)
    # If the line is empty, don't print anything
    elif stripped_line == '\n':
        continue
    # Indent non-Box lines
    else:
        print('---', stripped_line)
#+END_SRC
- Before automate everything, we run the code with lots of ~print()~ statements so that we can see what's happening

**** Collect the positive results
#+BEGIN_SRC python
letter_locations = []

for line in letters:
    stripped_line = line.strip()
    is_box = stripped_line.startswith("Box ")
    if is_box == True:
        letter_locations.append(stripped_line)
#+END_SRC

**** Compare the manifest and the letters
#+BEGIN_SRC python
print('Items in manifest:', len(manifest_list))
print('Letters:', len(letter_locations))
#+END_SRC

** Looping Over Data Sets
*** "Processing small files" exercise from Conditionals
glob operator

** Writing Functions
*** Break programs down into functions to make them easier to understand
- Human beings can only keep a few items in working memory at a time.
- Understand larger/more complicated ideas by understanding and combining pieces, e.g.:
  - Components in a machine.
  - Lemmas when proving theorems.
Functions serve the same purpose in programs:
  1. Encapsulate complexity so that we can treat it as a single “thing”.
  2. Enables re-use: Write one time, use many times.

*** Define a function using ~def~ with a name, parameters, and a block of code
#+BEGIN_SRC python
def print_greeting():
    print('Hello!')
#+END_SRC
- Begin the definition of a new function with ~def~, followed by the name of the function.
- Must obey the same rules as variable names.
- Parameters in parentheses; empty parentheses if the function doesn’t take any inputs.
- Colon, then an indented block of code

*** Defining a function does not run it
- Like assigning a value to a variable
- Must call the function to execute the code it contains.
#+BEGIN_SRC python
print_greeting()
#+END_SRC

*** Arguments in call are matched to parameters in definition
- Specify parameters when defining a function; these become variables when the function is executed
- By default (if you don’t name the arguments when calling the function) the arguments will be matched to parameters in the order the parameters are defined in the function.
#+BEGIN_SRC python
def print_date(year, month, day):
    joined = '/'.join([year, month, day])
    print(joined)

print_date(1871, 3, 19)
#+END_SRC

#+BEGIN_SRC python
# If you name the arguments you can specify any order
print_date(month=3, day=19, year=1871)
#+END_SRC

*** Functions may return a result to their caller using ~return~
- Use ~return ...~ to give a value back to the caller
- May occur anywhere in the function, but functions are easier to understand if return occurs:
  - At the start to handle special cases
  - At the very end, with a final result
- ~return~ ends the function's execution and /returns/ you to the code that originally called the function
#+BEGIN_SRC python
def average(values):
    "Return average of values, or None if no values are supplied."

    if len(values) == 0:
        return None
    return sum(values) / len(values)
#+END_SRC
- Docstring provides function help
- Use triple quotes if you need the docstring to span multiple lines: ~"""Like this"""~
- Here, the ~if~ statement "falls through" to the second ~return~ when ~values != 0~
- For maximum clarity, you could add ~else~ before the outer ~return~

#+BEGIN_SRC python
a = average([1, 3, 4])
print('average of actual values:', a)
#+END_SRC

#+BEGIN_SRC python
print('average of empty list:', average([]))
#+END_SRC

#+BEGIN_SRC python
# Every function returns something
result = print_date(1871, 3, 19)
print('result of call is:', result)
#+END_SRC

** Dictionaries
- Dictionaries are sets of key/value pairs
- Instead of being indexed by position, they are indexed by key
#+BEGIN_SRC python
ages = {'Derek': 42,
        'Bill': 24,
        'Susan': 37}

print(ages['Derek'])
#+END_SRC

#+BEGIN_SRC python
location = {'latitude': [37.28306, 'N'],
            'longitude': [120.50778, 'W']}

for key, val in location.items():
    print(key, 'is', val[0], val[1])
#+END_SRC

** Optional
- Checking performance
- Dictionaries
- List comprehensions
- Exceptions
- Paths as an example of increasing abstraction
- Variable Scope
- Programming Style

** Homework
*** Revisit the ~str~ documentation with an eye towards using the string processing methods for cleaning up data
*** How would you determine which letters and/or manifest items are missing?

* Week 3: Data manipulation with Pandas, stats with Statsmodels, ML with Scikit-Learn

** Reading Tabular Data into DataFrames

** Pandas DataFrames
shape , head, tail, info, describe
methods ("." means "belongs to")

** Batch processing, .py files, and editors

** Statsmodels
https://www.statsmodels.org/stable/index.html
** Scikit-Learn
*** Which estimator?
https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html
https://scikit-learn.org/stable/_static/ml_map.png

** Editorial comments about ML
1. We already have statistics, so do the reading
2. Talk to a domain expert
3. Beware parameter mining
4. All software is beta software (at best)

* Week 4: Visualization with Pandas, Seaborn, and/or Matplotlib
** What does it mean to be Pythonic?
The seamy history of Python plotting

* Credits
- Plotting and Programming in Python: http://swcarpentry.github.io/python-novice-gapminder/
- Humanities Python Tour: https://github.com/elliewix/humanities-python-tour/blob/master/Two-Hour-Beginner-Tour.ipynb
- Programming with Python: https://swcarpentry.github.io/python-novice-inflammation/index.html



* COMMENT How to export this document to other formats
** Export to Open Office using Emacs Org mode (preferred)
#+BEGIN_EXAMPLE
M-x org-odt-export-to-odt
#+END_EXAMPLE
** Export to Markdown using Pandoc
#+BEGIN_SRC bash
pandoc README.org -o README.md
#+END_SRC
** Export to Microsoft Word using Pandoc
#+BEGIN_SRC bash
# The --reference-doc flag is optional; it provides fine-grained control
# over the appearance of the output document
pandoc README.org -t markdown | pandoc --no-highlight --reference-doc=/home/gilgamesh/Dropbox/custom-reference.docx -o README.docx
#+END_SRC
